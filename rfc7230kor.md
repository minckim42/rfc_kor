# RFC 7230           
# HTTP/1.1 Message Syntax and Routing         
### June 2014


```
Table of Contents
   1. Introduction ....................................................5
      1.1. Requirements Notation ......................................6
      1.2. Syntax Notation ............................................6
   2. Architecture ....................................................6
      2.1. Client/Server Messaging ....................................7
      2.2. Implementation Diversity ...................................8
      2.3. Intermediaries .............................................9
      2.4. Caches ....................................................11
      2.5. Conformance and Error Handling ............................12
      2.6. Protocol Versioning .......................................13
      2.7. Uniform Resource Identifiers ..............................16
           2.7.1. http URI Scheme ....................................17
           2.7.2. https URI Scheme ...................................18
           2.7.3. http and https URI Normalization and Comparison ....19
   3. Message Format .................................................19
      3.1. Start Line ................................................20
           3.1.1. Request Line .......................................21
           3.1.2. Status Line ........................................22
      3.2. Header Fields .............................................22
           3.2.1. Field Extensibility ................................23
           3.2.2. Field Order ........................................23
           3.2.3. Whitespace .........................................24
           3.2.4. Field Parsing ......................................25
           3.2.5. Field Limits .......................................26
           3.2.6. Field Value Components .............................27
      3.3. Message Body ..............................................28
           3.3.1. Transfer-Encoding ..................................28
           3.3.2. Content-Length .....................................30
           3.3.3. Message Body Length ................................32
      3.4. Handling Incomplete Messages ..............................34
      3.5. Message Parsing Robustness ................................34
   4. Transfer Codings ...............................................35
      4.1. Chunked Transfer Coding ...................................36
           4.1.1. Chunk Extensions ...................................36
           4.1.2. Chunked Trailer Part ...............................37
           4.1.3. Decoding Chunked ...................................38
      4.2. Compression Codings .......................................38
           4.2.1. Compress Coding ....................................38
           4.2.2. Deflate Coding .....................................38
           4.2.3. Gzip Coding ........................................39
      4.3. TE ........................................................39
      4.4. Trailer ...................................................40
   5. Message Routing ................................................40
      5.1. Identifying a Target Resource .............................40
      5.2. Connecting Inbound ........................................41
      5.3. Request Target ............................................41
           5.3.1. origin-form ........................................42
           5.3.2. absolute-form ......................................42
           5.3.3. authority-form .....................................43
           5.3.4. asterisk-form ......................................43
      5.4. Host ......................................................44
      5.5. Effective Request URI .....................................45
      5.6. Associating a Response to a Request .......................46
      5.7. Message Forwarding ........................................47
           5.7.1. Via ................................................47
           5.7.2. Transformations ....................................49
   6. Connection Management ..........................................50
      6.1. Connection ................................................51
      6.2. Establishment .............................................52
      6.3. Persistence ...............................................52
           6.3.1. Retrying Requests ..................................53
           6.3.2. Pipelining .........................................54
      6.4. Concurrency ...............................................55
      6.5. Failures and Timeouts .....................................55
      6.6. Tear-down .................................................56
      6.7. Upgrade ...................................................57
   7. ABNF List Extension: #rule .....................................59
   8. IANA Considerations ............................................61
      8.1. Header Field Registration .................................61
      8.2. URI Scheme Registration ...................................62
      8.3. Internet Media Type Registration ..........................62
           8.3.1. Internet Media Type message/http ...................62
           8.3.2. Internet Media Type application/http ...............63
      8.4. Transfer Coding Registry ..................................64
           8.4.1. Procedure ..........................................65
           8.4.2. Registration .......................................65
      8.5. Content Coding Registration ...............................66
      8.6. Upgrade Token Registry ....................................66
           8.6.1. Procedure ..........................................66
           8.6.2. Upgrade Token Registration .........................67
   9. Security Considerations ........................................67
      9.1. Establishing Authority ....................................67
      9.2. Risks of Intermediaries ...................................68
      9.3. Attacks via Protocol Element Length .......................69
      9.4. Response Splitting ........................................69
      9.5. Request Smuggling .........................................70
      9.6. Message Integrity .........................................70
      9.7. Message Confidentiality ...................................71
      9.8. Privacy of Server Log Information .........................71
   10. Acknowledgments ...............................................72
   11. References ....................................................74
      11.1. Normative References .....................................74
      11.2. Informative References ...................................75
   Appendix A. HTTP Version History ..................................78
      A.1. Changes from HTTP/1.0  ....................................78
           A.1.1.  Multihomed Web Servers ............................78
           A.1.2.  Keep-Alive Connections ............................79
           A.1.3.  Introduction of Transfer-Encoding .................79
      A.2.  Changes from RFC 2616 ....................................80
   Appendix B. Collected ABNF ........................................82
   Index .............................................................85
```

# 1.  Introduction
하이퍼 텍스트 전송 프로토콜(HTTP, Hypertext Transfer Protocol)은 상태가 없는 어플리케이션 계층 요청/응답 프로토콜이며, 네트워크 기반의 하이퍼텍스트 정보 체계와의 유연한 상호작용을 위해 확장 가능한 의미론 및 자기 기술적 메시지 운반체를 사용합니다. 이 문서는 HTTP/1.1 규격을 집합적으로 구성하는 일련의 문서 중 첫 번째 문서입니다.

1. "Message Syntax and Routing" (this document)
2. "Semantics and Content" [RFC7231]
3. "Conditional Requests" [RFC7232]
4. "Range Requests" [RFC7233]
5. "Caching" [RFC7234]
6. "Authentication" [RFC7235]

이 HTTP/1.1 규격은 RFC 2616 alc RFC 2145를 (HTTP 버전에 대해서는) 폐기합니다. 이 규격은 또한 이전에 RFC 2817에서 정의된, 터널을 설정하는(establish) CONNECT의 쓰임을 갱신하고, RFC 2818에서 비공식적으로 설명되었던 "https" URI 스킴을 정의합니다.

HTTP는 정보 시스템의 일반 인터페이스 프로토콜입니다. 제공된 리소스 유형과 무관한 클라이언트에 통일된 인터페이스를 제공하여 서비스 구현 방법에 대한 세부 정보를 숨기도록 설계되었습니다. 마찬가지로, 서버는 각 클라이언트의 목적을 인식할 필요가 없습니다. HTTP 요청은 특정 유형의 클라이언트나 미리 결정된 응용 프로그램 단계 순서와 연결되지 않고 별도로 고려할 수 있습니다. 그 결과, 다양한 상황에서 효과적으로 사용할 수 있고 구현이 시간이 지남에 따라 독립적으로 발전할 수 있는 프로토콜이 개발되었습니다.

HTTP는 또한 비 HTTP 정보 시스템과의 통신을 변환하는 중간 프로토콜로 사용하도록 설계되었습니다. HTTP 프록시 및 게이트웨이는 다양한 프로토콜을 HTTP 서비스와 동일한 방법으로 클라이언트가 보고 조작할 수 있는 하이퍼텍스트 형식으로 변환하여 대체 정보 서비스에 대한 액세스를 제공할 수 있습니다.

이러한 유연성의 한 가지 결과는 인터페이스 뒤에서 발생하는 것과 관련하여 프로토콜을 정의할 수 없다는 것입니다.  대신, 우리는 통신의 구문, 수신된 통신의 의도, 수신자의 예상되는 행동을 정의하는 것으로 제한됩니다.  통신이 분리되어 고려되는 경우, 서버에서 제공하는 관찰 가능한 인터페이스에 대한 변경사항에 성공적인 조치가 반영되어야 합니다.  그러나 여러 클라이언트가 병렬로 동작할 수 있고 어쩌면 서로 다른 목적으로 동작할 수도 있기 때문에 단일 응답의 범위를 넘어서는 이러한 변경 사항을 관찰할 수 있도록 요구할 수는 없습니다.

이 문서는 HTTP에서 사용되거나 참조되는 아키텍처 요소를 설명하고, "http" 및 "https" URI 체계를 정의하며, 전체적인 네트워크 운영 및 연결 관리를 설명하며, HTTP 메시지 프레임 및 전달 요구사항을 정의합니다.  우리의 목표는 메시지 의미와 독립적인 HTTP 메시지 처리에 필요한 모든 메커니즘을 정의하여 메시지 파서 및 메시지 전달 매개 변수에 대한 전체 요구 사항 세트를 정의하는 것입니다.

## 1.1.  Requirements Notation

본 문서에서 "반드시 해야한다(MUST)", "절대로 해서는 안 된다(MUST NOT)", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL"이라는 키워드는 [RFC2119]에 설명된 대로 해석해야 합니다.

적합성 기준 및 오류 처리와 관련된 고려사항은 섹션 2.5에 정의되어 있습니다.

## 1.2.  Syntax Notation

이 규격은 섹션 7에 정의된 목록 확장자가 있는 [RFC5234]의 Argumented 베커스-나우어 양식(ABNF) 표기법을 사용하며, 이는 '#' 연산자를 사용하여 쉼표로 구분된 목록을 압축적으로 정의할 수 있도록 합니다('*' 연산자가 반복을 나타내는 방식과 유사함). 부록 B는 모든 목록 연산자가 표준 ABNF 표기법으로 확장되어 수집된 문법을 보여줍니다.

다음 핵심 규칙은 [RFC5234], 부록 B.1: ALPHA(문자), CR(캐리지 리턴), CRLF(CR LF), CTL(제어 문자), DIGIT(십진수 0-9), DQUOT(큰따옴표), HEXDIG(16진수 0-9/A-F/a-f), HTAB(수평 탭), LF(라인 피드), OCTET(8비트 데이터 시퀀스), SP(스페이스), VCHAR(출력가능한 아스키 문자)에 정의되어 있습니다.

# 2.  Architecture

HTTP는 월드 와이드 웹(WWW, World Wide Web) 아키텍처를 위해 개발되었으며, 시간이 지남에 따라 전 세계 하이퍼텍스트 시스템의 확장성 요구를 지원하기 위해 발전해 왔습니다. 이러한 아키텍처의 대부분은 HTTP를 정의하는 데 사용되는 용어 및 구문 프로덕션에 반영됩니다.

## 2.1.  Client/Server Messaging

HTTP는 신뢰할 수 있는 전송 계층 또는 세션 계층 "연결"(섹션 6)을 가로질러 메시지를 교환하며 작동하는 상태가 없는 요청/응답 프로토콜입니다. HTTP "클라이언트"는 하나 이상의 HTTP 요청을 보낼 목적으로 서버에 대한 연결을 설정하는 프로그램입니다.  HTTP "서버"는 HTTP 응답을 전송하여 HTTP 요청을 처리하기 위해 연결을 수신하는 프로그램입니다.

클라이언트 및 "서버"라는 용어는 이러한 프로그램이 특정 연결에 대해 수행하는 역할만 나타냅니다. 동일한 프로그램이 일부 연결에서는 클라이언트 역할을 하고 다른 연결에서는 서버 역할을 할 수 있습니다. "사용자 에이전트"란 브라우저, 스파이더(웹 기반 로봇), 명령줄 도구, 사용자 지정 응용 프로그램 및 모바일 앱을 포함하여 요청을 시작하는 다양한 클라이언트 프로그램을 말합니다. 오리진 서버라는 용어는 지정된 대상 리소스에 대한 권한 있는 응답을 생성할 수 있는 프로그램을 나타냅니다. "발신자"와 "수신자"라는 용어는 각각 주어진 메시지를 보내거나 받는 모든 구현을 나타냅니다.


